todo
    - implement socket close
    DONE
    - handle/ignore network errors on send/recv
    DONE

    - resend ICANHAZ if no reply received, in heartbeat
    - resend ICANHAZ-OK if duplicate request received
    - socket type validation at OHAI time
    - expanded test case
        - all socket types
    - enable/disable unreliability in driver
    - driver custom configuration? external config file?
    - start on vtx error console
    - start on vtx driver API
    - make autotooling and move stuff to proper directories
    - copy czmq doc page generation


++ Protocol sketch

[[code]]
NOM-1           = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:ROTFL )

use-peering     = C:OHAI ( S:OHAI-OK / S:ROTFL )
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK
                / C:ICANHAZ ( S:ICANHAZ-OK / S:ROTFL )
                / S:ICANHAZ ( C:ICANHAZ-OK / C:ROTFL )
                / C:NOM
                / S:NOM

ROTFL           = version reserved %b0000 %b0000 reason-text
version         = %b0001
reserved        = %b0000
reason-text     = *VCHAR

OHAI            = version reserved %b0001 %b0000 address
address         = ( broadcast / hostname / hostnumber ) ":" port
broadcast       = "*"
hostname        = label *( "." label )
label           = 1*( %x61-7A / DIGIT / "-" )
hostnumber      = 1*DIGIT "." 1*DIGIT "." 1*DIGIT "." 1*DIGIT
port            = 1*DIGIT

OHAI-OK         = version reserved %b0010 %b0000 address

HUGZ            = version reserved %b0011 %b0000
HUGZ-OK         = version reserved %b0100 %b0000

ICANHAZ         = version reserved %b0101 sequence zmq-payload
ICANHAZ-OK      = version reserved %b0110 sequence zmq-payload
sequence        = 4BIT          ; Incrementing for each ICANHAZ
zmq-payload     = 1*zmq-frame
zmq-frame       = frame-size frame-body
frame-size      = 2OCTET        ; In network byte order
frame-body      = *OCTET        ; frame-size octets

NOM             = version reserved %b0111 %b0000 zmq-payload
[[/code]]

and now the notes:

* A client opens a //peering// to a server. A server binds to and receives from some port. "Client" and "server" means exactly which node opens the peering, and which node accepts the peering. Nothing more. A peering has some state. We'll come to that.

* A client may start a peering-open dialog before the server is ready. In this case the client will send OHAIs repeatedly, at short intervals, until a server responds with OHAI-OK.

* The OHAI commands specifies an address, which the OHAI-OK command echoes. This lets a client broadcast OHAI to any listening server, and connect to the one that responds. We call this a //broadcast peering//.

* Once a peering is established, either peer can send unsolicited HUGZ, ICANHAZ, or NOM commands. A client can also send OHAI more than once to the same server, which may be needed since UDP can lose messages, e.g. the returning OHAI-OK.

* The ICANHAZ/ICANHAZ-OK commands are for the synchronous request-reply pattern (specifically for 0MQ REQ/REP sockets). NOM-1 does not use address envelopes, it is designed for single-hop request-reply.

* Since UDP will randomly drop messages, ICANHAZ implements a minimal resend capability. Each ICANHAZ command has an incrementing sequence number. The sender resends the ICANHAZ at short intervals at least as long as the peering is alive, until it receives a matching ICANHAZ-OK. The recipient will resend its last ICANHAZ-OK if it receives a duplicate request.

* Heartbeating consists of a ping-pong HUGZ/HUGZ-OK dialog. One peer sends HUGZ to the other, which replies with HUGZ-OK. Neither command has any payload. HUGZ and HUGZ-OK are not correlated. A peer should send HUGZ at regular intervals.

* Silence means a peer has died. A server should handle this by destroying all resources associated with that peering. A client should handle this by restarting the peering-open dialog.

++ Protocol abstract

NOM-1 is a minimal framing and control protocol over UDP. Main aspects:

* Enables virtual peerings (peerings) between peers.
* Minimal reliability for synchronous request-reply.
* Automatic heartbeating and peering garbage collection.
* Supports UDP broadcast ('any') peerings.
* Assumes unreliable, unordered datagram transport.
* Assumes maximum message size within normal MTU (512 bytes).
* Allows multipart messages within this limit.

++ Socket types supported

Uses PAIR to PAIR for application-to-driver peering, and uses emulated
socket types to define pattern semantics.

    USER     ROUTING  MX  ENV  FLOW
    ----     -------  --  ---  ----
    REQ      ROTATE    -   -   SYRQ
    REP      REPLY     -   -   SYRP
    DEALER   ROTATE    -   -   ASYN
    ROUTER   REPLY     -   Y   ASYN
    PUB      FANOUT    -   -   ASYN
    SUB      NONE      -   -   ASYN
    PUSH     ROTATE    -   -   ASYN
    PULL     NONE      -   -   ASYN
    PAIR     ROTATE    1   -   ASYN

For ROUTER, we need to create an envelope for the caller to manipulate.

++ Data structures

List of vockets:
    routing mechanism
    flow control
    max peerings
    single outgoing socket
    hash of all bindings
    hash of all peerings
    list of alive peerings

++ Protocol and commands

Frames have length defined by transport.
Frames that are not valid are discarded.
First frame in any dialog must be OHAI.
OHAI is always sent from active to passive.
I.e. connecting socket to binding socket.
Reply to OHAI is OHAI-OK or ERROR.
Any peer can send HUGZ, reply is HUGZ-OK or ERROR.
Any peer can send ICANHAZ, reply is ICANHAZ-OK or ERROR.
Any peer can send NOM, no reply.

++ Binding and connecting

Any peer can do multiple binds, multiple connects
Each bind creates public FD
    all public FDs are polled for input
    when new peer appears, creates a peering
All peerings share same private FD for output
    use unconnected socket and sendto
    each peering has a remote address for sendto
Input can arrive on private or public socket
    each frame needs to identify the peering #
    defined by peer that sends OHAI
    reused in all other peers for this peering

Connect can go to *, meaning 'anyone'
    if * used, server reply provides address
    if address used, recvfrom must be same addr
Binding is synchronous
    completes immediately, or fails with error code
Connection is asynchronous
    peering is ready after unspecified delay

++ Connection handshake

Client sends OHAI to server, either directly or via broadcast
Client includes server target address
Server receives message, replies with OHAI-OK
Server includes body of OHAI command
    - any unique string would work
    - allows clients to distinguish returning OHAI-OK commands

++ Error responses

ROTLF + error text
    closes peering if any
    -> bad socket pairing
    -> too many peers already connected
    -> shutting down
    -> ICANHAZ-OK to unknown request
    -> other faults?

++ Heartbeating

We use Belts and Braces heartbeating with optimizations, from the Guide (unpublished section).

++ Routing mechanisms

none
    output is not allowed, message is dropped.
reply-to
    message wrapped in envelope indicating origin peering,
    and this is used to re-route output if any.
load-balance
    message is sent to next peering, which is cycled to end
    of list of peerings. May be filtered by the selector.
carbon-copy
    message is sent to all peerings in turn, filtered by the
    selector.
direct
    message is sent to the single peering, asserts no more
    than one.

++ Incoming fair-queuing

TBD

With multiple peerings, read from peerings in round-robin fashion?
- this should be built into zloop reactor, not done in driver

++ Queuing while connecting

If no peerings are alive, don't fetch messages from internal pipe.

++ Error reporting and logging

TBD

Sent to inproc://vtx/logger PUB socket.
Format is
    S: udp: some message here
    where S = I, W, E

VTX provides logger that will collect and print all output.

++ Request-reply Emulation

Several issues here. One is UDP message loss, which we have to handle here
otherwise REQ sockets will break too often. Two is complexity of multihop
request-reply (address envelope). Three is state machine in REQ and REP
socket emulation.

Normal 0MQ REQ/REP one-hop requires: REQ adds null part to request, DEALER
distributes request, ROUTER generates identity and prepends to request,
REP removes and stores envelope, REP rewraps reply, ROUTER pops identity
and uses to route reply, DEALER forwards reply, REQ removes null part.

If we restrict our REQ/REP to one hop, we can simplify: REQ distributes
request, REP stores peering ID, and uses to route reply. Much simpler.

For reliability, REQ can resend request as long as it has not received a
reply, and REP can resend reply when it gets a duplicate request. The
simplest model is that we hold 'last request' and 'last reply' for each
peering. We can then resend requests, and resend replies as needed. If
the peering does down, this data can be cleared. So reliability is over
UDP, but not over peer failure. (That can be handled at a higher level.)

To distinguish new requests from duplicate resent requests, we use a
sequence number that is incremented in each command. Should be held per
peering.

For the state machine, we need to emulate in/out blocking. Simplest is
to configure vocket with an "synchronize" option, either NULL, REQ, or
REP.

++ Router Implementation

The ROUTER semantics don't require generated identities, just any way to
address a specific peering. We'll use the peering id and prefix that to
the message as an envelope frame.

++ Security & monitoring aspects

TBD

Set limit on peerings per vocket
Set limit on peerings per driver
Configurable timeout on peerings
Blocklist of bad hosts (invalid data, old versions)
Reporting of protocol errors
Reporting of died peers

++ Socket detailed analysis

REP = request-reply server:
    [REP]<--->[DEALER]
    routing model: N peers, reply-to addressing
    bind to *:port
    receive message from addr
    if message is OHAI, (re)register peering
        and send back ack
    else
        lookup peering from sender addr
    create envelope with peering id
    send to pipe
    in main thread:
        REP socket receives message from pipe
        REP socket removes & saves envelope
        app reads request from REP socket
        app sends reply to REP socket
        REP socket wraps reply in envelope
        REP socket sends message to pipe
    recv from pipe
    remove envelope to give peering id
    send reply to peering addr
        save last reply per peering
        resend if asked to

REQ = request-reply client:
    [REQ]<--->[DEALER]
    routing model: 1 single peer, direct addressing
    connect to address:port
        send OHAI handshake
        wait for ack
            repeat until successful
        if address was '*', replying peer is addr
        (how can we provide this back to caller app?)
            vtx_getsockopt (something)
    in main thread:
        app sends request to socket
        socket sends message to pipe
    recv from pipe
    send to peering addr
    wait for reply
        repeat until successful
        using message sequence number

DEALER = asynchronous server:
    [DEALER]<--->[DEALER]
    routing model: N peers, reply-to addressing
    same, except caller has DEALER socket
    caller has to manage envelope manually

PUB = publisher:
    [PUB]<--->[SUB]
    routing model: cc to all peers
    bind to *:port
    receive message from addr
    register new peerings as for REP
    also, prefix filter for each peering
    each message sent by app, cc to all peerings
    doing prefix match on filter first
    using non-connected UDP sockets, sendto each address

SUB = subscriber:
    [SUB]<--->[PUB]
    routing model: none, input only
    connect to address:port or *:port
    handshake as for REQ socket, but also sending filter
    can connect multiple times to different addresses
    using non-connected UDP socket, recv on socket

PUSH = pusher:
    [PUSH]<--->[PULL]
    routing model: lb to all peers
    bind to interface:port

PULL = puller:
    [PULL]<--->[PUSH]
    routing model: none, input only
    connect to * or N addresses

++ VTX design constraints

* Bind/connect to at most one driver/transport, otherwise semantics will be weird. We might allow multiple drivers for dealer and push. For pub, it would not work.


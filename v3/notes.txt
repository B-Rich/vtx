Patterns for UDP

++ Protocol abstract

NOM-1 is a minimal framing and control protocol over UDP. Main aspects:

* Enables virtual connections (peerings) between peers.
* Minimal reliability for synchronous request-reply.
* Automatic heartbeating and peering garbage collection.
* Supports UDP broadcast ('any') connections.
* Assumes unreliable, unordered datagram transport.
* Assumes maximum message size within normal MTU (512 bytes).
* Allows multipart messages within this limit.

++ Socket types supported

Uses PAIR to PAIR for application-to-driver connection, and uses emulated
socket types to define pattern semantics.

    USER     ROUTING  MX  ENV  FLOW
    ----     -------  --  ---  ----
    REQ      ROTATE    -   -   SYRQ
    REP      REPLY     -   -   SYRP
    DEALER   ROTATE    -   -   ASYN
    ROUTER   REPLY     -   Y   ASYN
    PUB      FANOUT    -   -   ASYN
    SUB      NONE      -   -   ASYN
    PUSH     ROTATE    -   -   ASYN
    PULL     NONE      -   -   ASYN
    PAIR     ROTATE    1   -   ASYN

For ROUTER, we need to create an envelope for the caller to manipulate.

++ Data structures

List of vockets:
    routing mechanism
    flow control
    max peerings
    single outgoing socket
    hash of all bindings
    hash of all peerings
    list of alive peerings

++ Protocol and commands

Frame:
    length is implicitly specified
    header          2 bytes:
        version         4 bits (hi)
        reserved        4 bits (lo)
        command         4 bits (hi)
        sequence        4 bits (lo)
    body            0..MSGMAX - 2 bytes

Commands:
    ROTFL           %x00
    OHAI            %x01
    OHAI_OK         %x02
    HUGZ            %x03
    HUGZ_OK         %x04
    ICANHAZ         %x05
    ICANHAZ_OK      %x06
    NOM             %x07

Frames have length defined by transport.
Frames that are not valid are discarded.
First frame in any dialog must be OHAI.
OHAI is always sent from active to passive.
I.e. connecting socket to binding socket.
Reply to OHAI is OHAI-OK or ERROR.
Any peer can send HUGZ, reply is HUGZ-OK or ERROR.
Any peer can send ICANHAZ, reply is ICANHAZ-OK or ERROR.
Any peer can send NOM, no reply.

++ Binding and connecting

Any peer can do multiple binds, multiple connects
Each bind creates public FD
    all public FDs are polled for input
    when new peer appears, creates a peering
All peerings share same private FD for output
    use unconnected socket and sendto
    each peering has a remote address for sendto
Input can arrive on private or public socket
    each frame needs to identify the peering #
    defined by peer that sends OHAI
    reused in all other peers for this peering

Connect can go to *, meaning 'anyone'
    if * used, server reply provides address
    if address used, recvfrom must be same addr
Binding is synchronous
    completes immediately, or fails with error code
Connection is asynchronous
    peering is ready after unspecified delay

++ Connection handshake

Client sends OHAI to server, either directly or via broadcast
Client includes server target address
Server receives message, replies with OHAI-OK
Server includes body of OHAI command
    - any unique string would work
    - allows clients to distinguish returning OHAI-OK commands

++ OHAI command

Specifies
    header
    address connecting to, as string
        - will be echoed on OHAI-OK
    tbd
        origin socket type (REQ, REP, etc.)
        for socket validation

++ Error responses

ROTLF + error text
    closes peering if any
    -> bad socket pairing
    -> too many peers already connected
    -> shutting down
    -> other faults?

++ Heartbeating

We use heartbeating to garbage-collect dead peerings.
Applies to each peering:
    Default TTL is TT seconds.
    Assumed latency for transport is LL seconds.
    Send HUGZ at (TT - LL) seconds.
    Expire peering when it reaches TTL expiry time.
Response to HUGZ is HUGZ-OK.
    send ping, set timer
    if no response before timer, lower peering
    if ping-ok, set new timer...

++ Routing mechanisms

none
    output is not allowed, message is dropped.
reply-to
    message wrapped in envelope indicating origin peering,
    and this is used to re-route output if any.
load-balance
    message is sent to next peering, which is cycled to end
    of list of peerings. May be filtered by the selector.
carbon-copy
    message is sent to all peerings in turn, filtered by the
    selector.
direct
    message is sent to the single peering, asserts no more
    than one.

++ Incoming fair-queuing

TBD

With multiple peerings, read from peerings in round-robin fashion?
- this should be built into zloop reactor, not done in driver

++ Queuing while connecting

If no peerings are alive, don't fetch messages from internal pipe.

++ Error reporting and logging

TBD

Sent to inproc://vtx/logger PUB socket.
Format is
    S: udp: some message here
    where S = I, W, E

VTX provides logger that will collect and print all output.

++ Reliable request-reply

REQ sockets will die/block if message gets lost. And UDP will lose messages
quite frequently (10-20% of the time when loaded). So, we implement a minimal
resend/retry mechanism:

    Send as ICANHAZ
    High 4 bits of control byte are sequence nbr
    Recipient tracks last received sequence nbr per peering
    Outgoing reply is sent as ICANHAZ-OK
    Set to last received sequence nbr
    Stored/saved per peering
    If duplicate request arrives, old reply is resent

++ 0MQ message encoding

For NOM, ICANHAZ, ICANHAZ-OK commands, body is encoded 0MQ message:

    [length] [frame data]

Where length is 0-254, or 255 + 2 further bytes in network order. Total
message size must fit into msgmax for transport (512 bytes - headers).

++ Security & monitoring aspects

TBD

Set limit on peerings per vocket
Set limit on peerings per driver
Configurable timeout on peerings
Blocklist of bad hosts (invalid data, old versions)
Reporting of protocol errors
Reporting of died peers

++ Socket detailed analysis

REP = request-reply server:
    [REP]<--->[DEALER]
    routing model: N peers, reply-to addressing
    bind to *:port
    receive message from addr
    if message is HELO, (re)register peering
        and send back ack
    else
        lookup peering from sender addr
    create envelope with peering id
    send to pipe
    in main thread:
        REP socket receives message from pipe
        REP socket removes & saves envelope
        app reads request from REP socket
        app sends reply to REP socket
        REP socket wraps reply in envelope
        REP socket sends message to pipe
    recv from pipe
    remove envelope to give peering id
    send reply to peering addr
        save last reply per peering
        resend if asked to

REQ = request-reply client:
    [REQ]<--->[DEALER]
    routing model: 1 single peer, direct addressing
    connect to address:port
        send HELO handshake
        wait for ack
            repeat until successful
        if address was '*', replying peer is addr
        (how can we provide this back to caller app?)
            vtx_getsockopt (something)
    in main thread:
        app sends request to socket
        socket sends message to pipe
    recv from pipe
    send to peering addr
    wait for reply
        repeat until successful
        using message sequence number

DEALER = asynchronous server:
    [DEALER]<--->[DEALER]
    routing model: N peers, reply-to addressing
    same, except caller has DEALER socket
    caller has to manage envelope manually

PUB = publisher:
    [PUB]<--->[SUB]
    routing model: cc to all peers
    bind to *:port
    receive message from addr
    register new peerings as for REP
    also, prefix filter for each peering
    each message sent by app, cc to all peerings
    doing prefix match on filter first
    using non-connected UDP sockets, sendto each address

SUB = subscriber:
    [SUB]<--->[PUB]
    routing model: none, input only
    connect to address:port or *:port
    handshake as for REQ socket, but also sending filter
    can connect multiple times to different addresses
    using non-connected UDP socket, recv on socket

PUSH = pusher:
    [PUSH]<--->[PULL]
    routing model: lb to all peers
    bind to interface:port

PULL = puller:
    [PULL]<--->[PUSH]
    routing model: none, input only
    connect to * or N addresses

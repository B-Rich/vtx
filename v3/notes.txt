Patterns for UDP

++ Protocol abstract

ZeroMQ Datagram Transfer Protocol, ZDTP. It's a minimal framing and control
protocol over UDP. Main aspects:

* Enables virtual connections (links) between peers.
* Minimal reliability for synchronous request-reply.
* Automatic heartbeating and link garbage collection.
* Supports UDP broadcast ('any') connections.
* Assumes unreliable, unordered datagram transport.
* Assumes maximum message size within normal MTU (512 bytes).
* Allows multipart messages within this limit.

++ Socket types supported

Use PAIR to PAIR for all pipes, and use emulated socket type to define
pattern semantics.

    USER     ROUTING  MX  ENV FLOW
    ----     -------  --  --- ----
    REQ      ROTATE    -   -  SYRQ
    REP      REPLY     -   -  SYRP
    DEALER   ROTATE    -   -  ASYN
    ROUTER   REPLY     -   Y  ASYN
    PUB      FANOUT    -   -  ASYN
    SUB      NONE      -   -  ASYN
    PUSH     ROTATE    -   -  ASYN
    PULL     NONE      -   -  ASYN
    PAIR     ROTATE    1   -  ASYN

For ROUTER, we need to create an envelope for the caller to manipulate.

++ Data structures

List of sockets:
    routing mechanism
        int routing
    flow control
    array of public FDs
        int public []
    single private FD
        int private
    list of links:
        struct sockaddr_in addr
        time to live


++ Protocol and commands

Frame:
    length is implicitly specified
    header          2 bytes:
        version         4 bits (hi)
        reserved        4 bits (lo)
        command         4 bits (hi)
        sequence        4 bits (lo)
    body            0..MSGMAX - 2 bytes

Commands:
    %x00    ERROR
    %x01    START
    %x02    START-OK
    %x03    PING
    %x04    PING-OK
    %x05    SYNREQ
    %x06    SYNREQ-OK
    %x07    ASYNC
    %x08    END

Frames have length defined by transport.
Frames that are not valid are discarded.
First frame in any dialog must be CONNECT.
CONNECT is always sent from active to passive.
I.e. connecting socket to binding socket.
Reply to CONNECT is CONNECT-OK or ERROR.
Any peer can send PING, reply is PING-OK or ERROR.
Any peer can send SYNREQ, reply is SYNREQ-OK or ERROR.
Any peer can send ASYNC, no reply.

++ Binding and connecting

Any peer can do multiple binds, multiple connects
Each bind creates public FD
    all public FDs are polled for input
    when new peer appears, creates a link
All links share same private FD for output
    use unconnected socket and sendto
    each link has a remote address for sendto
Input can arrive on private or public socket
    each frame needs to identify the link #
    defined by peer that sends CONNECT
    reused in all other peers for this link

Connect can go to *, meaning 'anyone'
    if * used, server reply provides address
    if address used, recvfrom must be same addr
Binding is synchronous
    completes immediately, or fails with error code
Connection is asynchronous
    link is ready after unspecified delay

++ Connection handshake

Client sends CONNECT to server, either directly or via broadcast
Client includes server target address
Server receives message, replies with CONNECT-OK
Server includes body of CONNECT command
    - any unique string would work
    - allows clients to distinguish returning CONNECT-OK commands

++ CONNECT command

Specifies
    header
    address connecting to, as string
        - will be echoed on CONNECT-OK

    tbd
    origin socket type (REQ, REP, etc.)
    selector, as binary string

++ Heartbeating

We use heartbeating to garbage collect dead links.
Applies to each link:
    Default TTL is 30 seconds.
    Assumed latency for transport is 5 seconds.
    Any incoming traffic on link is taken as "alive".
    Send PING at (30 - 5) seconds.
    Expire link when it reaches TTL expiry time.
Response to PING is PONG.

++ Routing mechanisms

none
    output is not allowed, message is dropped.
reply-to
    message wrapped in envelope indicating origin link,
    and this is used to re-route output if any.
load-balance
    message is sent to next link, which is cycled to end
    of list of links. May be filtered by the selector.
carbon-copy
    message is sent to all links in turn, filtered by the
    selector.
direct
    message is sent to the single link, asserts no more
    than one.

++ Incoming fair-queuing

With multiple links, read from links in round-robin fashion.

++ Queuing while connecting

If no links are alive, don't fetch messages from internal pipe.

++ Error reporting and logging

Sent to inproc://vtx/logger PUB socket.
Format is
    S: udp: some message here
    where S = I, W, E

VTX provides logger that will collect and print all output.

++ Reliable request-reply

REQ sockets will die/block if message gets lost. So, we implement a
minimal resend/retry mechanism:

    Send as SYNREQ
    High 4 bits of control byte are sequence nbr
    Recipient tracks last received sequence nbr per link
    Outgoing reply is sent as SYNREP
    Set to last received sequence nbr
    Stored/saved per link
    If duplicate request arrives, old reply is resent

++ 0MQ message encoding

For ASYNC, SYNREQ, SYNREP commands, body is encoded 0MQ message:

    [length] [frame data]

Where length is 0-254, or 255 + 2 further bytes in network order. Total
message size must fit into msgmax for transport (512 bytes - headers).

++ Socket detailed analysis

REP = request-reply server:
    [REP]<--->[DEALER]
    routing model: N peers, reply-to addressing
    bind to *:port
    receive message from addr
    if message is HELO, (re)register link
        and send back ack
    else
        lookup link from sender addr
    create envelope with link id
    send to pipe
    in main thread:
        REP socket receives message from pipe
        REP socket removes & saves envelope
        app reads request from REP socket
        app sends reply to REP socket
        REP socket wraps reply in envelope
        REP socket sends message to pipe
    recv from pipe
    remove envelope to give link id
    send reply to link addr
        save last reply per link
        resend if asked to

REQ = request-reply client:
    [REQ]<--->[DEALER]
    routing model: 1 single peer, direct addressing
    connect to address:port
        send HELO handshake
        wait for ack
            repeat until successful
        if address was '*', replying peer is addr
        (how can we provide this back to caller app?)
            vtx_getsockopt (something)
    in main thread:
        app sends request to socket
        socket sends message to pipe
    recv from pipe
    send to link addr
    wait for reply
        repeat until successful
        using message sequence number

DEALER = asynchronous server:
    [DEALER]<--->[DEALER]
    routing model: N peers, reply-to addressing
    same, except caller has DEALER socket
    caller has to manage envelope manually

PUB = publisher:
    [PUB]<--->[SUB]
    routing model: cc to all peers
    bind to *:port
    receive message from addr
    register new links as for REP
    also, prefix filter for each link
    each message sent by app, cc to all links
    doing prefix match on filter first
    using non-connected UDP sockets, sendto each address

SUB = subscriber:
    [SUB]<--->[PUB]
    routing model: none, input only
    connect to address:port or *:port
    handshake as for REQ socket, but also sending filter
    can connect multiple times to different addresses
    using non-connected UDP socket, recv on socket

PUSH = pusher:
    [PUSH]<--->[PULL]
    routing model: lb to all peers
    bind to interface:port

PULL = puller:
    [PULL]<--->[PUSH]
    routing model: none, input only
    connect to * or N addresses
